<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 4-Track Studio: Composer Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@magenta/music@1.23.1/dist/magentamusic.min.js"></script>
    <style>
        /* --- CORE --- */
        body { user-select: none; -webkit-user-select: none; background-color: #09090b; overflow: hidden; }
        
        /* --- WAVEFORM --- */
        #waveform-wrapper {
            position: relative; height: 80px; background: #18181b;
            border-radius: 6px; overflow: hidden; border: 1px solid #27272a; 
            touch-action: none; cursor: crosshair;
        }
        #selection-box {
            position: absolute; top: 0; bottom: 0;
            background: rgba(99, 102, 241, 0.2); 
            border-left: 1px solid #818cf8; border-right: 1px solid #818cf8;
            pointer-events: none; display: none; z-index: 10;
        }
        .keyboard-frame::-webkit-scrollbar { height: 4px; }
        .keyboard-frame::-webkit-scrollbar-track { background: #000; }
        .keyboard-frame::-webkit-scrollbar-thumb { background: #333; border-radius: 2px; }

        /* --- DECKS --- */
        .deck-container {
            flex: 0 0 auto; height: 100px;
            background: #18181b; border: 1px solid #27272a; 
            border-radius: 6px; padding: 4px;
            display: flex; flex-direction: column; margin-bottom: 4px;
            transition: opacity 0.2s;
        }
        .deck-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 4px 4px 4px; height: 20px;
            font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.05em; font-weight: 700;
        }
        .toggle-btn {
            background: #27272a; border: 1px solid #3f3f46; color: #71717a; 
            padding: 1px 6px; border-radius: 3px; font-size: 0.6rem;
            cursor: pointer; transition: all 0.1s; position: relative; z-index: 20;
        }
        .toggle-btn.active { color: #000; font-weight: bold; border-color: transparent; }
        .toggle-btn[data-deck="melody"].active { background: #06b6d4; }
        .toggle-btn[data-deck="chords"].active { background: #a855f7; }
        .toggle-btn[data-deck="bass"].active { background: #f97316; }
        .toggle-btn[data-deck="drums"].active { background: #ef4444; }
        
        .deck-disabled .keyboard-frame, .deck-disabled .drum-track { opacity: 0.2; filter: grayscale(100%); pointer-events: none; }

        /* --- KEYBOARDS --- */
        .keyboard-frame {
            position: relative; flex-grow: 1; width: 100%;
            background: #000; padding: 2px 0;
            border-radius: 4px; overflow-x: auto; overflow-y: hidden; white-space: nowrap;
            box-shadow: inset 0 0 10px #000;
        }
        .key-container { display: inline-block; position: relative; height: 100%; margin: 0 10px; }
        
        .key {
            display: inline-block; position: relative; vertical-align: top; 
            width: 26px; height: 100%;
            background: #e4e4e7; border: 1px solid #52525b; border-radius: 0 0 3px 3px;
            z-index: 1; margin-right: -1px; transition: transform 0.05s, background-color 0.05s;
        }
        .key.black {
            width: 16px; height: 60%; background: #18181b; margin-left: -8px; margin-right: -8px; 
            z-index: 10; border: 1px solid #000; border-bottom: 2px solid #333;
        }
        #deck-melody .key.active { background: #06b6d4 !important; transform: translateY(2px); box-shadow: 0 0 15px #06b6d4; }
        #deck-melody .key.black.active { background: #0891b2 !important; }
        #deck-chords .key.active { background: #a855f7 !important; transform: translateY(2px); box-shadow: 0 0 15px #a855f7; }
        #deck-chords .key.black.active { background: #9333ea !important; }
        #deck-bass .key.active { background: #f97316 !important; transform: translateY(2px); box-shadow: 0 0 15px #f97316; }
        #deck-bass .key.black.active { background: #ea580c !important; }

        /* --- DRUMS --- */
        .drum-track {
            height: 100%; width: 100%; background: #000; border-radius: 4px; 
            display: flex; align-items: center; justify-content: center; gap: 10px;
            box-shadow: inset 0 0 10px #000; padding: 6px;
        }
        .drum-pad {
            flex: 1; height: 100%; max-width: 140px;
            border-radius: 4px; background: #27272a; border: 2px solid #3f3f46;
            display: flex; align-items: center; justify-content: center; 
            font-size: 0.8rem; color: #71717a; font-weight: 800; letter-spacing: 0.1em;
            transition: all 0.05s; cursor: pointer;
        }
        .drum-pad.kick.active { background: #ef4444; color: white; box-shadow: 0 0 20px #ef4444; transform: scale(0.95); border-color: #fff; }
        .drum-pad.snare.active { background: #eab308; color: black; box-shadow: 0 0 20px #eab308; transform: scale(0.95); border-color: #fff; }

        /* --- LOADER --- */
        #loader-overlay {
            position: fixed; inset: 0; background: rgba(9,9,11,0.95); z-index: 100;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .loader-bar-bg { width: 300px; height: 4px; background: #27272a; border-radius: 2px; overflow: hidden; margin-top: 20px; }
        .loader-bar-fill { height: 100%; background: #6366f1; width: 0%; transition: width 0.1s; }
        .loader-text { font-family: monospace; font-size: 12px; color: #818cf8; margin-top: 10px; }
        
        /* Sliders */
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%; background: #818cf8; cursor: pointer; margin-top: -4px; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #3f3f46; border-radius: 2px; }
        
        .control-group { background: #18181b; border: 1px solid #27272a; border-radius: 6px; padding: 8px; }
    </style>
</head>
<body class="text-zinc-300 font-sans h-screen overflow-hidden flex flex-col">

    <header class="bg-zinc-900 border-b border-zinc-800 p-2 shrink-0 flex justify-between items-center">
        <h1 class="text-sm font-bold text-indigo-400 flex items-center gap-2">
            <span>üß†</span> AI Studio <span class="text-[10px] text-zinc-400 bg-zinc-800 px-1.5 py-0.5 rounded border border-zinc-700">Composer 5.0</span>
        </h1>
        <div class="flex gap-2">
            <input type="file" id="audioInput" accept="audio/*" class="hidden">
            <button onclick="document.getElementById('audioInput').click()" class="bg-zinc-800 hover:bg-zinc-700 text-zinc-300 px-3 py-1 rounded text-[10px] uppercase font-bold border border-zinc-700 transition flex items-center gap-1">
                <span>üìÇ</span> Load
            </button>
            <button id="btn-midi" disabled class="bg-blue-900/20 hover:bg-blue-900/40 text-blue-400 disabled:opacity-20 disabled:cursor-not-allowed px-3 py-1 rounded text-[10px] uppercase font-bold border border-blue-800/50 transition flex items-center gap-1">
                <span>üíæ</span> Export MIDI
            </button>
        </div>
    </header>

    <main class="flex-grow flex flex-col p-2 gap-2 overflow-y-auto w-full max-w-5xl mx-auto">
        
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-2 shrink-0">
            
            <div class="lg:col-span-8 bg-zinc-900 p-2 rounded border border-zinc-800 flex flex-col gap-1">
                <div class="flex justify-between items-end">
                    <span class="text-[9px] text-zinc-500 font-mono uppercase tracking-widest flex items-center gap-2">
                        <span>Input Waveform</span>
                        <span id="key-display" class="text-[8px] bg-indigo-900/30 text-indigo-400 border border-indigo-500/30 px-1 rounded hidden">KEY: C MAJ</span>
                        <span id="bpm-display" class="text-[8px] bg-orange-900/30 text-orange-400 border border-orange-500/30 px-1 rounded hidden">120 BPM</span>
                    </span>
                    <span id="time-display" class="text-[9px] font-mono text-green-400">0.00s</span>
                </div>
                <div id="waveform-wrapper">
                    <canvas id="waveform-canvas"></canvas>
                    <div id="selection-box"></div>
                </div>
            </div>

            <div class="lg:col-span-4 flex flex-col gap-2">
                <div class="control-group grid grid-cols-2 gap-x-4 gap-y-2">
                    <div>
                        <div class="flex justify-between text-[9px] text-zinc-400 mb-1">
                            <span>DRUM SENS</span><span id="lbl-drum">50%</span>
                        </div>
                        <input type="range" id="rng-drum" min="10" max="95" value="50" class="w-full">
                    </div>
                    <div>
                        <div class="flex justify-between text-[9px] text-zinc-400 mb-1">
                            <span>NOTE SENS</span><span id="lbl-note-sens">30%</span>
                        </div>
                        <input type="range" id="rng-note-sens" min="0" max="80" value="30" class="w-full">
                    </div>
                    
                    <div class="col-span-2">
                        <div class="flex justify-between text-[9px] text-zinc-400 mb-1">
                            <span title="Forces Monophony & Quantizes Rhythm">INTELLIGENCE (QUANTIZE/FIX)</span><span id="lbl-clarity">80%</span>
                        </div>
                        <input type="range" id="rng-clarity" min="0" max="100" value="80" class="w-full">
                    </div>

                    <div class="col-span-2 flex items-center gap-2 mt-1 bg-black/40 p-2 rounded border border-zinc-800">
                        <input type="checkbox" id="chk-filters" checked class="accent-indigo-500 w-3 h-3 cursor-pointer">
                        <label for="chk-filters" class="flex flex-col cursor-pointer select-none w-full">
                            <div class="flex justify-between items-center w-full">
                                <span class="text-[9px] text-green-400 font-bold">ENABLE ENGINEERED FILTERS</span>
                                <span class="text-[8px] text-zinc-600">3-STAGE</span>
                            </div>
                            <div class="flex justify-between text-[8px] text-zinc-500 mt-0.5">
                                <span>HPF 300Hz</span>
                                <span>Cut 7kHz</span>
                                <span>LPF 12kHz</span>
                            </div>
                        </label>
                    </div>
                </div>

                <div class="bg-zinc-900 p-2 rounded border border-zinc-800 grid grid-cols-2 gap-2 h-full">
                    <button id="btn-preview" disabled class="bg-zinc-700 hover:bg-zinc-600 text-[10px] py-1.5 rounded transition font-medium text-zinc-300">üîä RAW PREVIEW</button>
                    <button id="btn-stop" disabled class="bg-red-900/30 hover:bg-red-900/50 text-red-300 text-[10px] py-1.5 rounded transition font-medium border border-red-900/30">‚ñ† STOP</button>
                    <button id="btn-analyze" disabled class="col-span-2 bg-gradient-to-r from-indigo-700 to-indigo-600 hover:from-indigo-600 hover:to-indigo-500 text-white py-2 rounded font-bold text-xs shadow-lg shadow-indigo-900/20 transition flex flex-col items-center justify-center leading-none gap-1 border border-indigo-600">
                        <span>2. RUN PIPELINE</span>
                        <span class="text-[8px] font-normal opacity-80 font-mono">EXTRACT -> TOP VOICE -> COMPOSE</span>
                    </button>
                    <button id="btn-replay" disabled class="col-span-2 bg-indigo-600 hover:bg-indigo-500 text-white py-1.5 rounded font-bold text-[10px] transition border border-indigo-500 shadow-lg shadow-indigo-900/20">‚ñ∂ PLAY RESULT</button>
                </div>
            </div>
        </div>

        <div id="status" class="text-center text-[9px] text-yellow-500 font-mono py-1 shrink-0 h-4"></div>

        <div class="flex flex-col flex-grow min-h-0">
            <div class="deck-container" id="container-melody">
                <div class="deck-header text-cyan-400"><span>Melody (Extracted Top Voice)</span><button class="toggle-btn active" data-deck="melody">ON</button></div>
                <div class="keyboard-frame" id="deck-melody"></div>
            </div>
            <div class="deck-container" id="container-chords">
                <div class="deck-header text-purple-400"><span>Harmony (Remaining Chord Body)</span><button class="toggle-btn active" data-deck="chords">ON</button></div>
                <div class="keyboard-frame" id="deck-chords"></div>
            </div>
            <div class="deck-container" id="container-bass">
                <div class="deck-header text-orange-400"><span>Bass (Low)</span><button class="toggle-btn active" data-deck="bass">ON</button></div>
                <div class="keyboard-frame" id="deck-bass"></div>
            </div>
            <div class="deck-container" style="height: 120px;" id="container-drums">
                <div class="deck-header text-red-400"><span>Rhythm (Kick / Snare)</span><button class="toggle-btn active" data-deck="drums">ON</button></div>
                <div class="drum-track">
                    <div class="drum-pad kick" id="pad-kick">KICK</div>
                    <div class="drum-pad snare" id="pad-snare">SNARE</div>
                </div>
            </div>
        </div>
    </main>

    <div id="loader-overlay">
        <div class="w-12 h-12 border-4 border-zinc-800 border-t-indigo-500 rounded-full animate-spin"></div>
        <div class="loader-bar-bg"><div class="loader-bar-fill" id="load-bar"></div></div>
        <div class="loader-text" id="load-text">Initializing AI...</div>
        <div class="loader-sub" id="load-sub"></div>
    </div>

    <div id="composer-panel" class="fixed bottom-4 right-4 w-64 bg-zinc-900 border border-zinc-700 rounded-lg shadow-2xl overflow-hidden z-50 flex flex-col font-sans transition-all duration-300 transform translate-y-0">
        <div class="bg-zinc-800 p-2 flex justify-between items-center border-b border-zinc-700">
            <h3 class="text-xs font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
                ‚ú® AI COMPOSER
            </h3>
            <button onclick="toggleComposer()" class="text-zinc-500 hover:text-white text-xs">‚ñº</button>
        </div>

        <div id="composer-body" class="p-3 flex flex-col gap-3">
            
            <div>
                <div class="flex justify-between text-[9px] text-zinc-400 mb-1">
                    <span>BARS TO GENERATE</span>
                    <span id="lbl-bars" class="text-cyan-400">4</span>
                </div>
                <input type="range" id="rng-bars" min="2" max="16" value="4" class="w-full h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer">
            </div>

            <div>
                <div class="flex justify-between text-[9px] text-zinc-400 mb-1">
                    <span>CREATIVITY (TEMP)</span>
                    <span id="lbl-temp" class="text-purple-400">1.1</span>
                </div>
                <input type="range" id="rng-temp" min="0.5" max="1.5" step="0.1" value="1.1" class="w-full h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer">
            </div>

            <div class="grid grid-cols-2 gap-2">
                <button id="btn-generate-ai" class="col-span-2 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 text-white text-[10px] font-bold py-2 rounded shadow-lg transition disabled:opacity-50 disabled:cursor-not-allowed">
                    GENERATE MELODY
                </button>
                <button id="btn-undo-ai" disabled class="bg-zinc-800 hover:bg-zinc-700 text-zinc-400 text-[9px] py-1 rounded border border-zinc-700 transition disabled:opacity-20">
                    ‚Ü∂ UNDO ADDITION
                </button>
                <button id="btn-clear-ai" class="bg-zinc-800 hover:bg-red-900/30 text-zinc-400 hover:text-red-400 text-[9px] py-1 rounded border border-zinc-700 transition">
                    üóëÔ∏è CLEAR
                </button>
            </div>

            <div id="ai-status" class="text-[8px] text-zinc-500 text-center font-mono h-3 leading-none">
                Ready to compose.
            </div>
        </div>
    </div>

    <script>
    // --- WORKER FOR DRUMS ---
    const drumWorkerCode = `
    self.onmessage = function(e) {
        const { buffer, sampleRate, drumSens } = e.data;
        if (!buffer || buffer.length === 0) { self.postMessage({ drums: [] }); return; }

        const FFT_SIZE = 2048; const HOP_SIZE = 512; const binFreq = sampleRate / FFT_SIZE;
        const win = new Float32Array(FFT_SIZE);
        for(let i=0; i<FFT_SIZE; i++) win[i] = 0.5 * (1 - Math.cos(2*Math.PI*i/(FFT_SIZE-1)));
        const bins = new Float32Array(FFT_SIZE);
        const drums = [];

        const kStart = Math.ceil(40/binFreq); const kEnd = Math.ceil(150/binFreq);
        const sStart = Math.ceil(2000/binFreq);
        let prevLow = 0;

        for(let i=0; i < buffer.length - FFT_SIZE; i += HOP_SIZE) {
            for(let j=0; j<FFT_SIZE; j++) bins[j] = buffer[i+j] * win[j];
            const spec = computeSpectrum(bins);
            let lowE=0; for(let b=kStart; b<kEnd; b++) lowE+=spec[b];
            let hiE=0; for(let b=sStart; b<spec.length/2; b++) hiE+=spec[b];
            const flux = lowE - prevLow; prevLow = lowE;
            let isKick = false, isSnare = false;
            const kickThresh = 5 * drumSens;
            if(flux > kickThresh) {
                const snareRatio = hiE / (lowE + 1); 
                if (snareRatio > 0.8) isSnare = true; else isKick = true;
            }
            if(isKick) drums.push({ time: i/sampleRate, type: 'kick' });
            if(isSnare) drums.push({ time: i/sampleRate, type: 'snare' });
        }
        self.postMessage({ drums });
    };
    function computeSpectrum(input) {
        const n = input.length; const r = new Float32Array(input); const i_arr = new Float32Array(n);
        const fft = (r, i) => {
            const l = r.length; if(l <= 1) return; const h = l/2;
            const er = new Float32Array(h), ei = new Float32Array(h), or = new Float32Array(h), oi = new Float32Array(h);
            for(let k=0; k<h; k++) { er[k]=r[2*k]; ei[k]=i[2*k]; or[k]=r[2*k+1]; oi[k]=i[2*k+1]; }
            fft(er, ei); fft(or, oi);
            for(let k=0; k<h; k++) {
                const a = -2*Math.PI*k/l; const c = Math.cos(a); const s = Math.sin(a);
                const tr = c*or[k] - s*oi[k], ti = c*oi[k] + s*or[k];
                r[k] = er[k] + tr; i[k] = ei[k] + ti; r[k+h] = er[k] - tr; i[k+h] = ei[k] - ti;
            }
        };
        fft(r, i_arr);
        const m = new Float32Array(n/2);
        for(let j=0; j<n/2; j++) m[j] = Math.sqrt(r[j]**2 + i_arr[j]**2);
        return m;
    }
    `;

    // --- GLOBAL VARIABLES ---
    let audioCtx, audioBuffer, drumWorker, sourceNode = null;
    let selection = { start: 0, end: 1 };
    let analyzedNotes = [], analyzedDrums = [];
    let detectedBPM = 120;
    // FIX: GLOBAL KEY SCOPE FOR COMPOSER
    let detectedKey = { root: 0, type: 'major' }; 
    let polySynth, bassSynth, kickSynth, snareSynth;
    let deckState = { melody: true, chords: true, bass: true, drums: true };
    let activeTimeouts = [];
    let musicModel = null;
    let currentFileName = "studio_session";
    const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

    const ui = {
        file: document.getElementById('audioInput'),
        canvas: document.getElementById('waveform-canvas'),
        wrapper: document.getElementById('waveform-wrapper'),
        box: document.getElementById('selection-box'),
        time: document.getElementById('time-display'),
        status: document.getElementById('status'),
        loader: document.getElementById('loader-overlay'),
        loadBar: document.getElementById('load-bar'),
        loadText: document.getElementById('load-text'),
        loadSub: document.getElementById('load-sub'),
        btnPreview: document.getElementById('btn-preview'),
        btnAnalyze: document.getElementById('btn-analyze'),
        btnReplay: document.getElementById('btn-replay'),
        btnStop: document.getElementById('btn-stop'),
        btnMidi: document.getElementById('btn-midi'),
        rngDrum: document.getElementById('rng-drum'),
        lblDrum: document.getElementById('lbl-drum'),
        rngNoteSens: document.getElementById('rng-note-sens'),
        lblNoteSens: document.getElementById('lbl-note-sens'),
        rngClarity: document.getElementById('rng-clarity'),
        lblClarity: document.getElementById('lbl-clarity'),
        chkFilters: document.getElementById('chk-filters'),
        padKick: document.getElementById('pad-kick'),
        padSnare: document.getElementById('pad-snare'),
        keyDisplay: document.getElementById('key-display'),
        bpmDisplay: document.getElementById('bpm-display')
    };

    // --- INIT ---
    window.addEventListener('load', () => {
        initAudioContextOnly();
        generateKeyboards();
        setTimeout(() => document.querySelectorAll('.keyboard-frame').forEach(el => el.scrollLeft = (el.scrollWidth-el.clientWidth)/2), 100);
        
        const blob = new Blob([drumWorkerCode], { type: 'application/javascript' });
        drumWorker = new Worker(URL.createObjectURL(blob));
        drumWorker.onmessage = (e) => {
            const rawDrums = filterDrums(e.data.drums); 
            performMusicalIntelligence(rawDrums);
        };
        hideLoader();
    });

    function initAudioContextOnly() { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    async function ensureAudioEngine() {
        if(audioCtx.state === 'suspended') await audioCtx.resume();
        if(!polySynth) {
            await Tone.start();
            polySynth = new Tone.PolySynth(Tone.Synth, { envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.5 }, oscillator: { type: "triangle" } }).toDestination(); polySynth.volume.value = -8;
            bassSynth = new Tone.MonoSynth({ oscillator: { type: "sawtooth" }, filter: { Q: 2, type: "lowpass", rollover: -12 }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.4, release: 0.1 } }).toDestination(); bassSynth.volume.value = -5;
            kickSynth = new Tone.MembraneSynth().toDestination();
            snareSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0 } }).toDestination(); snareSynth.volume.value = -10;
        }
        if (!musicModel) musicModel = new mm.OnsetsAndFrames('https://storage.googleapis.com/magentadata/js/checkpoints/transcription/onsets_frames_uni');
    }

    // --- UI HANDLERS ---
    ui.rngDrum.addEventListener('input', (e) => ui.lblDrum.textContent = e.target.value + '%');
    ui.rngNoteSens.addEventListener('input', (e) => ui.lblNoteSens.textContent = e.target.value + '%');
    ui.rngClarity.addEventListener('input', (e) => ui.lblClarity.textContent = e.target.value + '%');
    
    document.querySelectorAll('.toggle-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const d = e.target.dataset.deck; deckState[d] = !deckState[d];
            e.target.textContent = deckState[d] ? 'ON' : 'OFF';
            e.target.classList.toggle('active', deckState[d]);
            const c = document.getElementById(`container-${d}`);
            if(c) deckState[d] ? c.classList.remove('deck-disabled') : c.classList.add('deck-disabled');
        });
    });

    function generateKeyboards() { createKeys('deck-bass', 24, 55); createKeys('deck-chords', 48, 83); createKeys('deck-melody', 60, 96); }
    function createKeys(id, s, e) {
        const el = document.getElementById(id); 
        let h = '<div class="key-container">';
        for(let i=s; i<=e; i++) { const k = NOTES[i%12]; const b = k.includes('#'); h += `<div class="key ${b?'black':'white'}" id="${id}-note-${i}"></div>`; }
        el.innerHTML = h + '</div>';
    }

    // --- WAVEFORM LOGIC ---
    let isDragging=false, dragAnchor=0;
    ui.wrapper.addEventListener('pointerdown', (e) => { if(!audioBuffer) return; isDragging=true; ui.wrapper.setPointerCapture(e.pointerId); dragAnchor=getX(e); selection.start=dragAnchor; selection.end=dragAnchor; updateSelUI(); });
    ui.wrapper.addEventListener('pointermove', (e) => { if(!isDragging)return; const x=getX(e); selection.start=Math.min(dragAnchor,x); selection.end=Math.max(dragAnchor,x); updateSelUI(); });
    ui.wrapper.addEventListener('pointerup', (e) => { isDragging=false; ui.wrapper.releasePointerCapture(e.pointerId); if(selection.end-selection.start<0.01){selection.start=0;selection.end=1;updateSelUI();} });
    function getX(e){ const r=ui.wrapper.getBoundingClientRect(); return Math.max(0,Math.min(1,(e.clientX-r.left)/r.width)); }
    function updateSelUI(){
        const w=ui.wrapper.clientWidth; ui.box.style.display='block'; ui.box.style.left=(selection.start*w)+'px'; ui.box.style.width=((selection.end-selection.start)*w)+'px';
        if(audioBuffer) ui.time.textContent=`${(selection.start*audioBuffer.duration).toFixed(2)}s - ${(selection.end*audioBuffer.duration).toFixed(2)}s`;
    }

    ui.file.addEventListener('change', async (e) => {
        if(!e.target.files.length) return;
        currentFileName = e.target.files[0].name.replace(/\.[^/.]+$/, "");
        showLoader("Decoding Audio...", 10);
        await ensureAudioEngine();
        try {
            const ab = await e.target.files[0].arrayBuffer();
            audioBuffer = await audioCtx.decodeAudioData(ab);
            drawWaveform(); selection.start=0; selection.end=1; updateSelUI();
            ui.btnAnalyze.disabled=false; ui.btnPreview.disabled=false; ui.btnReplay.disabled=true; ui.btnMidi.disabled=true;
            ui.keyDisplay.classList.add('hidden'); ui.bpmDisplay.classList.add('hidden');
            ui.status.textContent = "Audio Loaded. Select region and click RUN PIPELINE.";
        } catch(e) { console.error(e); ui.status.textContent = "Error loading file."; }
        hideLoader();
    });

    function drawWaveform() {
        const ctx=ui.canvas.getContext('2d'); const w=ui.wrapper.clientWidth, h=ui.wrapper.clientHeight;
        ui.canvas.width=w; ui.canvas.height=h;
        const l=audioBuffer.getChannelData(0); 
        const r=audioBuffer.numberOfChannels>1?audioBuffer.getChannelData(1):l;
        const step=Math.ceil(l.length/w); const amp=h/2;
        ctx.fillStyle='#18181b'; ctx.fillRect(0,0,w,h); ctx.beginPath(); ctx.strokeStyle='#22c55e';
        for(let i=0; i<w; i++){ 
            let min=1.0, max=-1.0; 
            for(let j=0; j<step; j++){ const idx = i*step+j; if(idx < l.length) { const v = (l[idx] + r[idx]) / 2; if(v<min)min=v; if(v>max)max=v; } } 
            ctx.moveTo(i,(1+min)*amp); ctx.lineTo(i,(1+max)*amp); 
        }
        ctx.stroke();
    }

    // --- PIPELINE & ZERO-COPY ---
    let rawAiNotes = [];

    ui.btnAnalyze.addEventListener('click', async () => {
        if(!audioBuffer) return;
        await ensureAudioEngine(); stopAll();

        try {
            const sIdx = Math.floor(selection.start * audioBuffer.length);
            const eIdx = Math.floor(selection.end * audioBuffer.length);
            const sliceLength = eIdx - sIdx;

            // 1. STEREO-TO-MONO SUMMING
            showLoader("Stage 1/5...", 15, "Stereo-to-Mono Summing");
            const monoData = new Float32Array(sliceLength);
            const lData = audioBuffer.getChannelData(0);
            const rData = audioBuffer.numberOfChannels > 1 ? audioBuffer.getChannelData(1) : null;
            for(let i=0; i<sliceLength; i++) {
                const srcIdx = sIdx + i;
                const l = lData[srcIdx] || 0;
                const r = rData ? (rData[srcIdx] || 0) : l;
                monoData[i] = (l + r) / 2;
            }

            const monoBuffer = audioCtx.createBuffer(1, sliceLength, audioBuffer.sampleRate);
            monoBuffer.copyToChannel(monoData, 0);

            if(!musicModel.isInitialized()) { showLoader("Loading AI Model...", 25, "Fetching Checkpoint"); await musicModel.initialize(); }

            // 2. ISOLATION FILTERS
            let aiInputBuffer = monoBuffer;
            if (ui.chkFilters.checked) {
                showLoader("Stage 2/5...", 40, "Running Filter Chain");
                const offlineCtx = new OfflineAudioContext(1, sliceLength, audioBuffer.sampleRate);
                const source = offlineCtx.createBufferSource();
                source.buffer = monoBuffer;
                const hpFilter = offlineCtx.createBiquadFilter(); hpFilter.type = "highpass"; hpFilter.frequency.value = 300; 
                const peakFilter = offlineCtx.createBiquadFilter(); peakFilter.type = "peaking"; peakFilter.frequency.value = 7000; peakFilter.Q.value = 1; peakFilter.gain.value = -15;
                const lpFilter = offlineCtx.createBiquadFilter(); lpFilter.type = "lowpass"; lpFilter.frequency.value = 12000;
                source.connect(hpFilter); hpFilter.connect(peakFilter); peakFilter.connect(lpFilter); lpFilter.connect(offlineCtx.destination);
                source.start();
                aiInputBuffer = await offlineCtx.startRendering();
            }

            // 3. AI TRANSCRIPTION
            showLoader("Stage 3/5...", 60, "Magenta AI Transcription");
            const ns = await musicModel.transcribeFromAudioBuffer(aiInputBuffer);
            rawAiNotes = ns.notes.map(n => ({ note: n.pitch, start: n.startTime, duration: n.endTime - n.startTime, mag: n.velocity / 127 }));

            // 4. DRUM EXTRACTION
            showLoader("Stage 4/5...", 80, "Spectral Flux Drum Analysis");
            const dSens = (100 - parseInt(ui.rngDrum.value))/100;
            drumWorker.postMessage({ buffer: monoData, sampleRate: audioBuffer.sampleRate, drumSens: dSens }, [monoData.buffer]); 

        } catch (e) {
            console.error(e);
            ui.status.textContent = "Error: File too large or Memory full.";
            hideLoader();
        }
    });

    // --- MUSIC THEORY INTELLIGENCE ---
    function performMusicalIntelligence(drums) {
        showLoader("Stage 5/5...", 90, "Applying Musical Intelligence");
        analyzedDrums = drums;
        
        const intelligence = parseInt(ui.rngClarity.value) / 100; // 0 to 1
        const noteSens = parseInt(ui.rngNoteSens.value) / 100;
        
        // A. Basic Filtering
        let notes = JSON.parse(JSON.stringify(rawAiNotes)).filter(n => n.mag >= noteSens);

        // B. BPM Estimation (from Kicks)
        detectedBPM = estimateBPM(drums);
        ui.bpmDisplay.textContent = `${detectedBPM} BPM`;
        ui.bpmDisplay.classList.remove('hidden');

        // C. Key Detection
        // FIX: Assign to Global Variable
        detectedKey = detectKey(notes);
        ui.keyDisplay.textContent = `KEY: ${NOTES[detectedKey.root]} ${detectedKey.type.toUpperCase()}`;
        ui.keyDisplay.classList.remove('hidden');

        // D. ADVANCED SPLIT: Top-Line Extraction (Top Note = Melody)
        const bass = [];
        const upper = [];
        notes.forEach(n => {
            if(n.note < 53) { n.role = 'bass'; bass.push(n); }
            else { upper.push(n); }
        });

        // 2. Separate Melody vs Chords from Upper
        const melody = [];
        const chords = [];
        
        if (upper.length > 0) {
            upper.sort((a,b) => a.start - b.start);
            const CLUSTER_WINDOW = 0.05; 
            let i = 0;
            while(i < upper.length) {
                const cluster = [upper[i]];
                let j = i + 1;
                while(j < upper.length && (upper[j].start - upper[i].start) < CLUSTER_WINDOW) {
                    cluster.push(upper[j]);
                    j++;
                }
                if (cluster.length === 1) {
                    cluster[0].role = 'melody';
                    melody.push(cluster[0]);
                } else {
                    cluster.sort((a,b) => a.note - b.note);
                    const topNote = cluster[cluster.length - 1];
                    const harmonyNotes = cluster.slice(0, cluster.length - 1);
                    topNote.role = 'melody';
                    melody.push(topNote);
                    harmonyNotes.forEach(n => { n.role = 'chords'; chords.push(n); });
                }
                i = j;
            }
        }

        const processedMelody = enforceMonophony(melody, intelligence);
        const processedBass = enforceMonophony(bass, intelligence);
        const processedChords = processBlockChords(chords, intelligence);

        if(intelligence > 0.5) {
            [...processedMelody, ...processedBass, ...processedChords].forEach(n => snapToKey(n, detectedKey));
        }

        analyzedNotes = [...processedMelody, ...processedBass, ...processedChords];
        
        ui.status.textContent = `Ready. BPM:${detectedBPM} | Key:${NOTES[detectedKey.root]} | Split by Top-Voice.`;
        ui.btnReplay.disabled = false; ui.btnMidi.disabled = false;
        hideLoader();
    }

    // --- INTELLIGENCE HELPERS ---

    function estimateBPM(drums) {
        const kicks = drums.filter(d => d.type === 'kick');
        if (kicks.length < 4) return 120;
        const intervals = [];
        for (let i = 0; i < kicks.length - 1; i++) {
            const diff = kicks[i+1].time - kicks[i].time;
            if(diff > 0.3 && diff < 1.0) intervals.push(diff);
        }
        if(intervals.length < 2) return 120;
        intervals.sort((a,b) => a-b);
        const median = intervals[Math.floor(intervals.length/2)];
        let bpm = 60 / median;
        while(bpm < 80) bpm *= 2;
        while(bpm > 160) bpm /= 2;
        return Math.round(bpm);
    }

    function detectKey(notes) {
        const counts = new Array(12).fill(0);
        notes.forEach(n => counts[n.note % 12]++);
        const majorProfile = [2, 0, 1, 0, 1, 1, 0, 2, 0, 1, 0, 1]; 
        let bestRoot = 0; let maxScore = -1;
        for(let root=0; root<12; root++) {
            let score = 0;
            for(let i=0; i<12; i++) {
                score += counts[(root + i) % 12] * majorProfile[i];
            }
            if(score > maxScore) { maxScore = score; bestRoot = root; }
        }
        return { root: bestRoot, type: 'major', scale: [0,2,4,5,7,9,11].map(x => (x+bestRoot)%12) };
    }

    function snapToKey(note, key) {
        if (key.scale.includes(note.note % 12)) return;
        let minDist = 100; let bestPitch = note.note;
        key.scale.forEach(pc => {
            const octave = Math.floor(note.note / 12);
            const candidates = [ (octave-1)*12 + pc, octave*12 + pc, (octave+1)*12 + pc ];
            candidates.forEach(c => {
                if(Math.abs(c - note.note) < minDist) { minDist = Math.abs(c - note.note); bestPitch = c; }
            });
        });
        note.note = bestPitch;
    }

    function enforceMonophony(notes, strength) {
        if(notes.length === 0) return [];
        notes.sort((a,b) => a.start - b.start);
        const result = [];
        for(let i=0; i<notes.length; i++) {
            let current = notes[i];
            if(strength > 0.5) {
                const beatSec = 60/detectedBPM;
                const grid = beatSec/4; 
                current.start = Math.round(current.start / grid) * grid;
            }
            if (result.length > 0) {
                const prev = result[result.length - 1];
                if (current.start < prev.start + prev.duration) {
                    prev.duration = Math.max(0.05, current.start - prev.start); 
                }
            }
            result.push(current);
        }
        return result.filter(n => n.duration > 0.05);
    }

    function processBlockChords(notes, strength) {
        if(notes.length === 0) return [];
        notes.sort((a,b) => a.start - b.start);
        const groups = [];
        let currentGroup = [notes[0]];
        for(let i=1; i<notes.length; i++) {
            const n = notes[i];
            const prev = currentGroup[0];
            if (Math.abs(n.start - prev.start) < 0.1) { currentGroup.push(n); } 
            else { groups.push(currentGroup); currentGroup = [n]; }
        }
        groups.push(currentGroup);
        const result = [];
        groups.forEach(group => {
            if(strength > 0.3) {
                const avgStart = group.reduce((s,n) => s+n.start, 0) / group.length;
                let finalStart = avgStart;
                if(strength > 0.6) {
                    const beatSec = 60/detectedBPM;
                    const grid = beatSec/4; 
                    finalStart = Math.round(avgStart / grid) * grid;
                }
                group.forEach(n => { n.start = finalStart; n.duration = Math.max(n.duration, 0.2); });
            }
            result.push(...group);
        });
        return result;
    }

    // --- PLAYBACK ---
    ui.btnReplay.addEventListener('click', async () => {
        await ensureAudioEngine(); stopAll(); ui.btnStop.disabled=false; const now = Tone.now();
        analyzedNotes.forEach(n => {
            if(!deckState[n.role] && n.role !== 'generated-melody') return; // Support AI generated
            const t = now + n.start;
            if(n.role === 'bass') bassSynth.triggerAttackRelease(Tone.Frequency(n.note, "midi"), n.duration, t, n.mag);
            else polySynth.triggerAttackRelease(Tone.Frequency(n.note, "midi"), n.duration, t, n.mag);
            scheduleVisual(n.role === 'bass' ? 'deck-bass' : (n.role === 'melody' || n.role === 'generated-melody' ? 'deck-melody' : 'deck-chords'), n.note, n.start, n.duration);
        });
        if(deckState.drums) {
            analyzedDrums.forEach(d => {
                const t = now + d.time;
                if(d.type === 'kick') { kickSynth.triggerAttackRelease("C1", "8n", t); scheduleDrumVisual('pad-kick', d.time); } 
                else { snareSynth.triggerAttackRelease("16n", t); scheduleDrumVisual('pad-snare', d.time); }
            });
        }
    });

    function scheduleVisual(deck, note, start, dur) { const t1 = setTimeout(() => document.getElementById(`${deck}-note-${note}`)?.classList.add('active'), start * 1000); const t2 = setTimeout(() => document.getElementById(`${deck}-note-${note}`)?.classList.remove('active'), (start+dur)*1000); activeTimeouts.push(t1, t2); }
    function scheduleDrumVisual(id, start) { const t = setTimeout(() => { const el = document.getElementById(id); el.classList.add('active'); setTimeout(() => el.classList.remove('active'), 150); }, start * 1000); activeTimeouts.push(t); }

    ui.btnPreview.addEventListener('click', async () => { if(!audioBuffer) return; await ensureAudioEngine(); stopAll(); ui.btnStop.disabled=false; const s = audioCtx.createBufferSource(); s.buffer = audioBuffer; s.connect(audioCtx.destination); s.start(0, selection.start*audioBuffer.duration, (selection.end-selection.start)*audioBuffer.duration); sourceNode = s; s.onended = () => ui.btnStop.disabled = true; });

    function stopAll() { if(polySynth) polySynth.releaseAll(); if(bassSynth) bassSynth.triggerRelease(); if(sourceNode) { try{sourceNode.stop()}catch(e){} sourceNode=null; } activeTimeouts.forEach(t => clearTimeout(t)); activeTimeouts=[]; document.querySelectorAll('.active').forEach(k => k.classList.remove('active')); ui.btnStop.disabled = true; }
    ui.btnStop.addEventListener('click', stopAll);

    function filterDrums(raw) {
        const res = []; let lastKick = -1; let lastSnare = -1;
        const KICK_COOLDOWN = 0.15; const SNARE_COOLDOWN = 0.20; 
        raw.forEach(d => {
            if(d.type === 'kick') { if (lastKick === -1 || d.time - lastKick > KICK_COOLDOWN) { res.push(d); lastKick = d.time; } } 
            else { if (lastSnare === -1 || d.time - lastSnare > SNARE_COOLDOWN) { res.push(d); lastSnare = d.time; } }
        });
        return res;
    }
    function showLoader(t,p,s){ ui.loader.style.display='flex'; ui.loadText.textContent=t; ui.loadBar.style.width=p+'%'; if(s)ui.loadSub.textContent=s; }
    function hideLoader(){ ui.loader.style.display='none'; }

    // --- MIDI EXPORT ---
    ui.btnMidi.addEventListener('click', () => {
        if(!analyzedNotes.length) return;
        const midiEvents = [];
        analyzedNotes.forEach(n => {
            if(!deckState[n.role] && n.role !== 'generated-melody') return;
            let ch = 0;
            if(n.role === 'chords') ch = 1;
            else if(n.role === 'bass') ch = 2;
            const vel = Math.max(0, Math.min(127, Math.floor((n.mag||0.8) * 127)));
            midiEvents.push({ t: n.start, type: 'noteOn', ch, note: n.note, vel });
            midiEvents.push({ t: n.start + n.duration, type: 'noteOff', ch, note: n.note, vel: 0 });
        });
        if(deckState.drums) {
            analyzedDrums.forEach(d => {
                const note = d.type === 'kick' ? 36 : 38;
                midiEvents.push({ t: d.time, type: 'noteOn', ch: 9, note: note, vel: 100 });
                midiEvents.push({ t: d.time + 0.1, type: 'noteOff', ch: 9, note: note, vel: 0 });
            });
        }
        midiEvents.sort((a, b) => {
            if(Math.abs(a.t - b.t) < 0.0001) return a.type === 'noteOff' ? -1 : 1;
            return a.t - b.t;
        });

        const trackData = [];
        let lastTick = 0;
        const ticksPerSec = 960; 

        function writeVLQ(delta) {
            let buffer = []; let d = delta;
            do { let byte = d & 0x7F; d >>= 7; if (buffer.length > 0) byte |= 0x80; buffer.push(byte); } while (d > 0);
            for(let i=buffer.length-1; i>=0; i--) trackData.push(buffer[i]);
        }

        midiEvents.forEach(e => {
            const currentTick = Math.round(e.t * ticksPerSec);
            const delta = Math.max(0, currentTick - lastTick);
            lastTick = currentTick;
            writeVLQ(delta);
            const status = (e.type === 'noteOn' ? 0x90 : 0x80) | e.ch;
            trackData.push(status); trackData.push(e.note); trackData.push(e.vel);
        });
        writeVLQ(0); trackData.push(0xFF, 0x2F, 0x00);

        const headerSize = 14; const trackHeaderSize = 8;
        const totalSize = headerSize + trackHeaderSize + trackData.length;
        const fileData = new Uint8Array(totalSize);

        const header = [0x4D, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, (480 >> 8) & 0xFF, 480 & 0xFF];
        fileData.set(header, 0);
        const trkHead = [0x4D, 0x54, 0x72, 0x6B, (trackData.length >> 24) & 0xFF, (trackData.length >> 16) & 0xFF, (trackData.length >> 8) & 0xFF, trackData.length & 0xFF];
        fileData.set(trkHead, 14);
        fileData.set(new Uint8Array(trackData), 22);

        const blob = new Blob([fileData], {type: 'audio/midi'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${currentFileName}_${Date.now()}.mid`; 
        a.click();
    });
    </script>

    <script>
    const CHECKPOINT_URL = 'https://storage.googleapis.com/magentadata/js/checkpoints/music_rnn/melody_rnn';
    let melodyRnn = null;
    let lastGeneratedChunkLength = 0;

    const composerUI = {
        panel: document.getElementById('composer-panel'),
        btnGen: document.getElementById('btn-generate-ai'),
        btnUndo: document.getElementById('btn-undo-ai'),
        btnClear: document.getElementById('btn-clear-ai'),
        rngBars: document.getElementById('rng-bars'),
        rngTemp: document.getElementById('rng-temp'),
        lblBars: document.getElementById('lbl-bars'),
        lblTemp: document.getElementById('lbl-temp'),
        status: document.getElementById('ai-status')
    };

    composerUI.rngBars.addEventListener('input', (e) => composerUI.lblBars.textContent = e.target.value);
    composerUI.rngTemp.addEventListener('input', (e) => composerUI.lblTemp.textContent = e.target.value);
    
    composerUI.btnGen.addEventListener('click', async () => {
        if (!analyzedNotes || analyzedNotes.length === 0) {
            updateAiStatus("No notes to continue!", "text-red-500"); return;
        }
        await generateContinuation();
    });

    composerUI.btnUndo.addEventListener('click', () => {
        if (lastGeneratedChunkLength > 0 && analyzedNotes.length >= lastGeneratedChunkLength) {
            analyzedNotes.splice(analyzedNotes.length - lastGeneratedChunkLength, lastGeneratedChunkLength);
            lastGeneratedChunkLength = 0;
            updateAiStatus("Last addition removed.", "text-yellow-500");
            composerUI.btnUndo.disabled = true;
        }
    });

    composerUI.btnClear.addEventListener('click', () => {
        analyzedNotes = analyzedNotes.filter(n => n.role !== 'generated-melody');
        updateAiStatus("Cleared AI notes.", "text-zinc-500");
    });

    function toggleComposer() {
        const body = document.getElementById('composer-body');
        body.classList.toggle('hidden');
    }

    function updateAiStatus(msg, colorClass = "text-zinc-500") {
        composerUI.status.textContent = msg;
        composerUI.status.className = `text-[8px] text-center font-mono h-3 leading-none ${colorClass}`;
    }

    async function generateContinuation() {
        composerUI.btnGen.disabled = true;
        try {
            if (!melodyRnn) {
                updateAiStatus("Loading MusicRNN...", "text-cyan-400 animate-pulse");
                melodyRnn = new mm.MusicRNN(CHECKPOINT_URL);
                await melodyRnn.initialize();
            }

            updateAiStatus("Reading context...", "text-blue-400");
            const melodyNotes = analyzedNotes.filter(n => n.role === 'melody' || n.role === 'generated-melody');
            if (melodyNotes.length === 0) throw new Error("No melody track found.");

            melodyNotes.sort((a, b) => a.start - b.start);
            
            // KEY TRANSPOSTION LOGIC
            const stepsToC = -detectedKey.root; 
            const STEPS_PER_QUARTER = 4;
            const qpm = detectedBPM;
            
            const lastNote = melodyNotes[melodyNotes.length - 1];
            const totalDuration = lastNote.start + lastNote.duration;

            const noteSequence = {
                notes: melodyNotes.map(n => ({ pitch: n.note + stepsToC, startTime: n.start, endTime: n.start + n.duration })),
                totalTime: totalDuration,
                quantizationInfo: { stepsPerQuarter: STEPS_PER_QUARTER },
                tempos: [{ qpm: qpm }]
            };

            const quantizedSeq = mm.sequences.quantizeNoteSequence(noteSequence, STEPS_PER_QUARTER);

            updateAiStatus("Dreaming...", "text-purple-400 animate-pulse");
            const barsToGen = parseInt(composerUI.rngBars.value);
            const stepsToGen = barsToGen * 4 * STEPS_PER_QUARTER; 
            const temperature = parseFloat(composerUI.rngTemp.value);

            const result = await melodyRnn.continueSequence(quantizedSeq, stepsToGen, temperature);

            updateAiStatus("Processing...", "text-green-400");
            const inputEndStep = quantizedSeq.totalQuantizedSteps;
            const secondsPerStep = 60 / qpm / STEPS_PER_QUARTER;
            const timeOffset = inputEndStep * secondsPerStep;

            const newNotes = result.notes.map(n => {
                return {
                    note: n.pitch - stepsToC, 
                    start: timeOffset + (n.quantizedStartStep * secondsPerStep),
                    duration: (n.quantizedEndStep - n.quantizedStartStep) * secondsPerStep,
                    mag: 0.8, 
                    role: 'generated-melody' 
                };
            });

            analyzedNotes.push(...newNotes);
            lastGeneratedChunkLength = newNotes.length;
            composerUI.btnUndo.disabled = false;
            updateAiStatus(`Added ${newNotes.length} notes!`, "text-green-500");

        } catch (err) {
            console.error(err);
            updateAiStatus("Error: " + err.message, "text-red-500");
        } finally {
            composerUI.btnGen.disabled = false;
        }
    }
    </script>
</body>
</html>

